- implementare l'event kernel --> user RINA_KERN_CONFIG_CHANGED, per avvisare
  le applicazioni che è necessario rifare un ipcps_fetch()

- limitare la lunghezza delle code nel kernel

- vmpi_provider_find_instance non dovrebbe essere bloccante

- flow entry in stato ALLOCATED ma mai associate ad un file descriptor con
  bind() dovrebbero sparire dopo un po', altrimenti c'è leakage

- rina-utils: routine di deserializzazione devono gestire errori di lunghezza

- vedere come inserire il campo lunghezza nel PCI header

- se si perde la PDU iniziale contenente il DRF è un casino, anche se c'è la
  ritrasmissione. Dal punto di vista del protocollo, infatti, come gestisco
  i pacchetti successivi (che arrivano prima che il trasmettitore si accorge
  di dover ritrasmettere la PDU con il DRF settato)? Sarebbe una stupidaggine
  buttare questi pacchetti. Sembra sia conveniente introdurre nel DTP un flag
  di stato "waitingForDRF" che aiuti a "forzare il DRF" quando esso non è
  presente ma dovrebbe

- proteggere l'accesso al flusso (fase di allocazione) con uno spinlock

- CDAP: supportare un semplice meccanismo di ritrasmissione, in caso la
  connessione CDAP sia supportata da un flusso non affidabile

- riflettere la close() di un file descriptor rina-io in a uipcp. Per fare
  questo, spostare il work flow.dfp.remove in flow.remove, e riutilizzare
  flow.remove (INIT_WORK) per fare la notifica in userspace

- VMPI: TX ring è probabilmente inutile per un utilizzo kernelspace-only

- riorganizzare uipcp-rib.cpp in modo da suddividerlo in più files

- serialize/unserialize: controllare boundary delle numtables
