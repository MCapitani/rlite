- implementare l'event kernel --> user RINA_KERN_CONFIG_CHANGED, per avvisare
  le applicazioni che è necessario rifare un ipcps_fetch()

- limitare la lunghezza delle code nel kernel

- vmpi_provider_find_instance non dovrebbe essere bloccante

- flow entry in stato ALLOCATED ma mai associate ad un file descriptor con
  bind() dovrebbero sparire dopo un po', altrimenti c'è leakage

- rimuovere usleep() hack in uipcp_server

- rina-utils: routine di deserializzazione devono gestire errori di lunghezza

- vedere come inserire il campo lunghezza nel PCI header

- se si perde la PDU iniziale contenente il DRF è un casino, anche se c'è la
  ritrasmissione. Dal punto di vista del protocollo, infatti, come gestisco
  i pacchetti successivi (che arrivano prima che il trasmettitore si accorge
  di dover ritrasmettere la PDU con il DRF settato)? Sarebbe una stupidaggine
  buttare questi pacchetti. Sembra sia conveniente introdurre nel DTP un flag
  di stato "waitingForDRF" che aiuti a "forzare il DRF" quando esso non è
  presente ma dovrebbe

- proteggere l'accesso al flusso (fase di allocazione) con uno spinlock

- problema: in rina_sdu_rx_flow() non c'è un controllo sulla dimensione
  massima della coda di ricezione per userspace. D'altronde in quel punto
  non si possono buttare pacchetti, altrimenti la ritrasmissione implementata
  dal normal ipcp non funzionerebbe. Bisogna, come minimo, che il normale
  controlli in normal_sdu_rx() se l'upper è userspace, ed in tal caso butti
  il pacchetto se la coda è troppo lunga, prima di aggiornare lo stato del
  DTP (e quindi gestire flow control, ristrasmissione, variabili di stato,
  etc.)
